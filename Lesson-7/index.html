<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Snake Game</title>
  <style>
    body {
      text-align: center;
    }

    #gameZone {
      margin: 30px auto;
      border: 5px solid #DAE2E9;
      line-height: 0;
    }

    #gameZone div {
      width: 15px;
      height: 15px;
      display: inline-block;
      border-left: 1px solid #f7fbfd;
      border-bottom: 1px solid #f7fbfd;
    }

    .part_body {
      background: #00C790;
    }

    .part_head {
      background: #008080;
    }

    .food {
      background: #8A9DE1;
    }

    .obstacle {
      background: #e18abd;
    }
  </style>
</head>

<body>

  <h1>Python</h1>
  <p id="info">:</p>
  <div id="gameZone"></div>
  <p> [SPACE] = Start / Pause, [ENTER] = New game</p>

  <script>

    "use strict"

    var cols = 24
      , rows = 20
      , countSectors = cols * rows
      , widthFildPx = cols * 15 + cols
      , cells = []
      , direction = { x: +1, y: 0 }
      , python = setStartPositionPartsPython()
      , positionFood = []
      , positionObstacle
      , countOfFoodEaten = 0
      , speedOfMovement = 300
      , isPauesed = false;

    // Высчитывает начальные позиции для змейки
    function setStartPositionPartsPython() {
      var position = cols * rows / 2;
      return [position, position - 1];
    };

    var gameBlockId = document.getElementById('gameZone');
    var infoBlockId = document.getElementById('info');
    document.addEventListener('keydown', dispatcherEventKey);
    // Указывает в стиле размер блока
    gameBlockId.style.width = widthFildPx + "px";

    function generationMap(cols, rows) {
      for (var i = 0; i < countSectors; i++) {
        cells[i] = document.createElement("div");
        gameBlockId.appendChild(cells[i]);
      }
    };

    // Высчитывает все события на поле связанные со змейкой
    function movementPython() {

      var lastPart = python[python.length - 1];

      // Когда проглоченная еда достигает конца хвоста змейка подрастает
      if (lastPart == positionFood[0]) {
        python.push(positionFood.shift())
      }

      cells[lastPart].className = '';

      // Задает для каждой части тела змейки позиции предыдущей части тела
      for (var i = python.length - 1; i > 0; i--) {
        python[i] = python[i - 1];
        cells[python[i]].className = 'part_body';
      }

      var _positionNewStepNum = convertAxesToPosition(direction);

      // Проверяет присутсвует ли голова на следущем ходу в собственном теле
      if (python.includes(python[0] + _positionNewStepNum)) {
        alert("Караул.. змейка ест саму себя!! Вы проиграли..");
        location.reload();
      }

      // python[0] += _positionNewStepNum;

      // Высчитывает следующий ход, когда стены прозрачные
      python[0] = moveThroughWall(python[0], _positionNewStepNum);
      cells[python[0]].className = 'part_head';

      // Проверяет равны ли координаты головы змейки и еды
      // повышает уровень сложности и создает новую еду
      if (python[0] == positionFood[0]) {
        createPositionFood();
        levelGameUp();
      }
      // console.log(positionFood)

      // Проверяет задана ли позиция для препятствия
      if (positionObstacle == undefined) {
        createPositionObstacle();
      }
      // Попала ли голова змейки в искуственную стенку
      if (python[0] == positionObstacle) {
        alert("Змейка разбилась об стенку!! Вы проиграли..");
        location.reload();
      }
    }

    // Создает еду на поле
    function createPositionFood() {
      var _num = Math.floor(Math.random() * countSectors);
      if (python.includes(_num)) {
        console.log("Ппц.. Еда сама хотела попасть сразу в желудок змейки");
        createPositionFood();
        return;
      }
      positionFood.push(_num);
      cells[_num].className = 'food';
    }

    // Высчитывает координаты нового хода сквозь стены для головы змейки  
    function moveThroughWall(_positionHeadNum, _positionNewStepNum) {
      var axesHead = converterPositionToAxes(_positionHeadNum);

      if (direction.x == -1 && axesHead.x <= 0)
        return _positionHeadNum + cols - 1;

      if (direction.y == -1 && axesHead.y <= 0)
        return cols * (rows - 1) + _positionHeadNum;

      if (direction.x == +1 && axesHead.x + 1 >= cols)
        return _positionHeadNum - cols + 1;

      if (direction.y == +1 && axesHead.y + 1 >= rows)
        return _positionHeadNum % cols;

      return _positionHeadNum += _positionNewStepNum;
    }
    
    // Конвертирует позицию на одной оси в декартову систему
    function converterPositionToAxes(_positionNum) {
      var x = _positionNum % cols;
      var y = Math.floor(_positionNum / cols);
      return { x: x, y: y };
    };
    
    // Конвертирует декартову систему координат в однуосевую
    function convertAxesToPosition(direction) {
      var position = direction.y * cols + direction.x;
      return position;
    };

    function dispatcherEventKey(e) {

      if (e.keyCode == 38 && direction.y != +1)
        return direction = { x: 0, y: -1 };

      if (e.keyCode == 40 && direction.y != -1)
        return direction = { x: 0, y: +1 };

      if (e.keyCode == 37 && direction.x != +1)
        return direction = { x: -1, y: 0 };

      if (e.keyCode == 39 && direction.x != -1)
        return direction = { x: +1, y: 0 };

      if (e.keyCode == 32)
        isPauesed = (!isPauesed) ? true : false;

      if (e.keyCode == 13)
        location.reload();
    };

    function infoGame() {
      infoBlockId.innerHTML = 'Food: ' + countOfFoodEaten + ' / Speed: ' + speedOfMovement + 'ms';
    }

    // Функция изменяет темп игры и подсчитывает съеденную еду
    function levelGameUp() {
      ++countOfFoodEaten;
      speedOfMovement -= 10;
      clearInterval(timerIteration);
      startTimerOfIterationGame();
      infoGame();
    }

    // Запуск таймера с изменяющимися интеравалами в меньшую сторону по уровню
    // Инициирует движение змейки 
    var timerIteration;

    function startTimerOfIterationGame() {
      timerIteration = setInterval(function () {
        if (!isPauesed) {
          movementPython();
        }
      }, speedOfMovement);
    }

    infoGame();
    generationMap();
    startTimerOfIterationGame();
    createPositionFood();

    // Самовызывающиеся функция создает таймер для 
    // временного отображения препятствий 
    var ticksForObstacle;

    function startTimerOfObstacle() {
      if (ticksForObstacle < 0) {
        cells[positionObstacle].className = '';
        positionObstacle = null;
        return;
      }
      ticksForObstacle--;
      setTimeout(startTimerOfObstacle, 1000);
    }

    // Функция создает препятсвие
    function createPositionObstacle() {
      var _num = Math.floor(Math.random() * countSectors);

      if (python.includes(_num)) {
        createPositionObstacle();
        return;
      }

      ticksForObstacle = 5;
      startTimerOfObstacle();
      
      positionObstacle = _num;
      cells[_num].className = 'obstacle';
    }

  </script>

</body>

</html>