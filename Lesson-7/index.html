<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Snake Game</title>
  <style>
    body {
      text-align: center;
    }

    #gameZone {
      margin: 30px auto;
      border: 5px solid #DAE2E9;
      line-height: 0;
    }

    #gameZone div {
      width: 15px;
      height: 15px;
      display: inline-block;
      border-left: 1px solid #f7fbfd;
      border-bottom: 1px solid #f7fbfd;
    }

    .part_body {
      background: #00C790;
    }

    .part_head {
      background: #008080;
    }

    .food {
      background: #8A9DE1;
    }

    .obstacle {
      background: #e18abd;
    }
  </style>
</head>

<body>

  <h1>Python</h1>
  <p id="info">:</p>
  <div id="gameZone"></div>
  <p> [SPACE] = Start / Pause, [ENTER] = New game</p>

  <script>

    "use strict"

    var cols = 24
      , rows = 20
      , countSectors = cols * rows
      , widthFildPx = cols * 15 + cols
      , cells = []
      , direction = { x: +1, y: 0 }
      , python = setStartPositionPartsPython()
      , positionFood = []
      , positionObstacle
      , countOfFoodEaten = 0
      , speedOfMovement = 400
      , isPauesed = false
      , timerIteration;

    function setStartPositionPartsPython() {
      var position = cols * rows / 2;
      return [position, position - 1];
    };

    var gameBlockId = document.getElementById('gameZone');
    var infoBlockId = document.getElementById('info');
    document.addEventListener('keydown', dispatcherEventKey);
    gameBlockId.style.width = widthFildPx + "px";

    function generationMap(cols, rows) {
      for (var i = 0; i < countSectors; i++) {
        cells[i] = document.createElement("div");
        gameBlockId.appendChild(cells[i]);
      }
    };

    function converterPositionToAxes(_positionNum) {
      var x = _positionNum % cols;
      var y = Math.floor(_positionNum / cols);
      return { x: x, y: y };
    };

    function convertAxesToPosition(direction) {
      var position = direction.y * cols + direction.x;
      return position;
    };

    function movementPython() {

      var lastPart = python[python.length - 1];

      if (lastPart == positionFood[0]) {
        python.push(positionFood.shift())
      }

      cells[lastPart].className = '';

      for (var i = python.length - 1; i > 0; i--) {
        python[i] = python[i - 1];
        cells[python[i]].className = 'part_body';
      }

      var _positionAddNewStepNum = convertAxesToPosition(direction);

      if (python.includes(python[0] + _positionAddNewStepNum)) {
        alert("Караул.. змейка ест сама себя!! Вы проиграли..");
        location.reload();
      }

      // python[0] += _positionAddNewStepNum;

      python[0] = moveThroughWall(python[0], _positionAddNewStepNum);
      cells[python[0]].className = 'part_head';

      if (python[0] == positionFood[0]) {
        createPositionFood();
        levelGameUp();
      }


      if (!positionObstacle) {
        createPositionObstacle();
      }

      if (python[0] == positionObstacle) {
        alert("Змейка разбилась об стенку!! Вы проиграли..");
        location.reload();
      }
    }

    function createPositionFood() {
      var _num = Math.floor(Math.random() * countSectors);
      if (python.includes(_num)) {
        console.log("Ппц.. Еда сама хотела попасть сразу в желудок змейки");
        createPositionFood();
        return;
      }
      positionFood.push(_num);
      cells[_num].className = 'food';
    }

    function moveThroughWall(_positionHeadNum, _positionAddStepNum) {
      var axesHead = converterPositionToAxes(_positionHeadNum);

      if (direction.x == -1 && axesHead.x <= 0)
        return _positionHeadNum + cols - 1;

      if (direction.y == -1 && axesHead.y <= 0)
        return cols * (rows - 1) + _positionHeadNum;

      if (direction.x == +1 && axesHead.x + 1 >= cols)
        return _positionHeadNum - cols + 1;

      if (direction.y == +1 && axesHead.y + 1 >= rows)
        return _positionHeadNum % cols;

      return _positionHeadNum += _positionAddStepNum;
    }

    function dispatcherEventKey(e) {

      if (e.keyCode == 38 && direction.y != +1)
        return direction = { x: 0, y: -1 };

      if (e.keyCode == 40 && direction.y != -1)
        return direction = { x: 0, y: +1 };

      if (e.keyCode == 37 && direction.x != +1)
        return direction = { x: -1, y: 0 };

      if (e.keyCode == 39 && direction.x != -1)
        return direction = { x: +1, y: 0 };

      if (e.keyCode == 32)
        isPauesed = (!isPauesed) ? true : false;

      if (e.keyCode == 13)
        location.reload();
    };

    function infoGame() {
      infoBlockId.innerHTML = 'Food: ' + countOfFoodEaten + ' / Speed: ' + speedOfMovement + 'ms';
    }

    function levelGameUp() {
      ++countOfFoodEaten;
      speedOfMovement -= 10;
      clearInterval(timerIteration);
      startTimerOfIterationGame();
      infoGame();
    }


    var timerIteration;

    function startTimerOfIterationGame() {
      timerIteration = setInterval(function () {
        if (!isPauesed) {
          movementPython();
          console.log(positionFood);
        }
      }, speedOfMovement);
    }

    generationMap();
    infoGame();
    startTimerOfIterationGame();
    createPositionFood();



    var ticksForObstacle;

    function startTimerOfObstacle() {
      if (ticksForObstacle < 0) {
        cells[positionObstacle].className = '';
        positionObstacle = null;
        return;
      }
      ticksForObstacle--;
      // console.log(ticksForObstacle);
      setTimeout(startTimerOfObstacle, 1000);
    }

    function createPositionObstacle() {
      var _num = Math.floor(Math.random() * countSectors);

      if (python.includes(_num)) {
        createPositionObstacle();
        return;
      }

      ticksForObstacle = 5;
      startTimerOfObstacle();
      
      positionObstacle = _num;
      cells[_num].className = 'obstacle';
    }

  </script>

</body>

</html>